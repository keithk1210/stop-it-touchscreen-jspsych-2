<!DOCTYPE html>

<html>

<!--

     _                    _ _
 ___| |_ ___  _ __       (_) |_
/ __| __/ _ \| '_ \ _____| | __|
\__ \ || (_) | |_) |_____| | |_
|___/\__\___/| .__/      |_|\__|
             |_|

AUTHORS: Luc Vermeylen & Frederick Verbruggen (2019)

DESCRIPTION: This is the jsPsych version of the stop-signal task

-->

<head> <!-- import the jsPsych core library, specific plugins, jquery and some other scripts-->

  <title>Stop Signal Task</title> <!-- defines a title in the browser tab -->

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js"> </script>


  <script type="text/javascript" src="js/jspsych-6.0.5/jspsych.js"></script>


  <!--
  -->
  <script type="text/javascript" src="https://lib.pavlovia.org/jspsych-pavlovia-2020.2.js"></script>
  <link href="js/jspsych-6.0.5/css/jspsych.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="styles.css">

  <script src="js/jspsych-6.0.5/plugins/jspsych-instructions.js"></script> <!-- plugins define specific tasks, e.g., presenting instructions -->

  <script src="js/jspsych-6.0.5/plugins/jspsych-html-keyboard-response.js"></script>
  <script src="js/jspsych-6.0.5/plugins/jspsych-html-button-response.js"></script>

  <script src="js/jspsych-6.0.5/plugins/jspsych-survey-text.js"></script> <!-- beta 6.1 version has the 'input required' function for text fields -->

  <script src="js/jspsych-6.0.5/plugins/jspsych-survey-multi-choice.js"></script>

  <script src="js/jspsych-6.0.5/plugins/jspsych-call-function.js"></script>
  <script src="js/jspsych-6.0.5/plugins/jspsych-fullscreen.js"></script>

  <!--
  <script type="text/javascript" src="https://lib.pavlovia.org/vendors/jquery-2.2.0.min.js"></script>
  -->
  
  <script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>

  <script src="js/bowser.js"></script> <!-- a browser and operating system detector -->

  <script src="js/sprintf.js"></script> <!-- format variables in a string, used for customizable feedback strings in which the variables are not yet declared -->
  <script src="js/custom-stop-signal-plugin.js"></script> <!-- custom plugin for the main stop-signal trial based on the image-keyboard-response plugin -->
  <script src="js/custom-goodbye-plugin.js"></script> 
  <!--
  <script src="js/custom-realeyes-plugin.js"></script> <!-- custom plugin for the main stop-signal trial based on the image-keyboard-response plugin -->
  -->
  

  <script src="js/jspsych-detect-held-down-keys.js"></script> <!-- custom plugin for detecting if a key is being held down -->
  <script src="configuration/experiment_variables.js"></script> <!-- parameters to configure the experiment -->

  <script src="configuration/text_variables.js"></script> <!-- holds all the text variables for easy modification/translation -->

  <script src="webgazer.js" type="text/javascript" ></script>
  <script src="https://unpkg.com/heatmap.js"></script>
  <!---
    <script src="reExperienceSdk.min.js"></script>
  -->

    <!--
    <script src="https://codesdwncdn.realeyesit.com/experience-sdk/xp/release/1/reExperienceSdk.min.js"></script>
  -->
 

 
  
  

</head>

<body>

</body>

<script>



  /* #########################################################################

  Initialize variables

  ######################################################################### */

  // Initialize some important variables

  var cameraStream = null;
  var mediaRecorder = null;
  var gazeData = [];
  var recordedChunks = [];
  const startTime = Date.now();

  function isDirectory(path) {
      if (path.split("/").length > 1 && path.split("/")[1].length > 0) {
          return true;
      } else {
          return false;
      }
  }

  function getDirectory(path) {
      return path.split("/")[0];
  }

  //function to count instances of a certain [x,y] coordinate
  function countCoordinates(pairs) {
    const counts = {};

    pairs.forEach(pair => {
      const key = JSON.stringify(pair); // Convert the pair to a string

      if (counts[key]) {
        counts[key]++;
      } else {
        counts[key] = 1;
      }
    });

    let dataPoints = [];
    console.log("counts:" )
    console.log(counts)

    for (const key in counts) {
      if (counts.hasOwnProperty(key)) {
        let coord = JSON.parse(key)
        dataPoints.push({
          x:coord[0],
          y:coord[1],
          value:counts[key]
        })
      }
    } 

    console.log("dataPoints ")
    console.log(dataPoints)

    return dataPoints;
  }

  

  function onFail() {
    console.error("Failed to start WebGazer. No stream available.");
    alert("Failed to start WebGazer. Please check your camera and permissions.");
  }

  async function initializeCameraStream() {
    try {
        cameraStream = await navigator.mediaDevices.getUserMedia({
            video: {
                width: { min: 320, ideal: 320 },
                height: { min: 240, ideal: 240 },
                facingMode: { ideal: "user" }
            },
            audio: false
        });

        mediaRecorder = new MediaRecorder(cameraStream);
        mediaRecorder.ondataavailable = handleDataAvailable;
        // mediaRecorder.onstop = handleStop;

        mediaRecorder.onstart = () => {
            console.log('MediaRecorder started');
        };

        mediaRecorder.onpause = () => {
            console.log('MediaRecorder paused');
        };

        mediaRecorder.onresume = () => {
            console.log('MediaRecorder resumed');
        };

        mediaRecorder.onerror = (event) => {
            console.error('MediaRecorder error:', event.error);
        };

        
        mediaRecorder.start(1000); // Request data every second
        console.log("Created new mediaRecorder:", mediaRecorder);
    } catch (error) {
        console.error('Error accessing camera:', error);
    }
}

  //event handler fo the mediaRecorder to store the video data.
  function handleDataAvailable(event) {
      //console.log("Attempting to handle data with size: " + event.data.size);
      if (event.data.size > 0) {
          recordedChunks.push(event.data);
          //console.log('Data available:', event.data);
      }
  }

  //event handler for the mediaRecorder to stop the recording and download the video.
  function handleStop() {
      const recordedBlob = new Blob(recordedChunks, { type: 'video/webm' });
      const videoUrl = URL.createObjectURL(recordedBlob);

      const a = document.createElement('a');
      a.style.display = 'none';
      a.href = videoUrl;
      console.log("Downloading this video... " + videoUrl);
      var subjID = 'defaultID'; // Replace this with actual participantID if available
      a.download = 'recorded-video' + subjID + '.webm';
      document.body.appendChild(a);
      //a.click();

      window.URL.revokeObjectURL(videoUrl);
      recordedChunks = [];
      console.log("STOP HANDLED!");

      uploadVideo(recordedBlob);
  }


  function stopRecording() {
      mediaRecorder.stop();
  }

// Function to upload video to an S3 bucket.
  async function uploadVideo(blob) {
      const reader = new FileReader();
      reader.onloadend = function() {
          const arrayBuffer = reader.result;
          const binaryData = new Uint8Array(arrayBuffer);

          fetch('/upload/video', {
              method: 'POST',
              headers: {
                  'Content-Type': 'application/octet-stream'
              },
              body: binaryData
          }).then(response => response.json())
            .then(data => console.log('Video uploaded successfully:', data))
            .catch(err => console.error('Error uploading video:', err));
      };
      reader.readAsArrayBuffer(blob);
  }

  // Function to send data about reaction time to an S3 bucket.
  async function uploadToLeaderboard(username,userID,responseTime) {
    const data = {
        username: username,
        userID: userID,
        responseTime: responseTime
    };

    try {
        const response = await fetch('/upload/leaderboard', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        });

        if (!response.ok) {
            throw new Error('Network response was not ok');
        }

        const responseData = await response.json();
        console.log('Data uploaded successfully:', responseData);
    } catch (error) {
        console.error('Error sending data:', error);
    }
  }

  async function uploadData(userID,csvString) {

    const data = {
        userID: userID,
        csvString: csvString
    };

    try {
        const response = await fetch('/upload/data', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        });

        if (!response.ok) {
            throw new Error('Network response was not ok');
        }

        const responseData = await response.json();
        console.log('Data uploaded successfully:', responseData);
    } catch (error) {
        console.error('Error sending data:', error);
    }
  }

  function accessPromiseResults(promises) {

    const leaderboardBody = document.getElementById("leaderboard").getElementsByTagName('tbody')[0];
    leaderboardBody.innerHTML = '';

    return Promise.allSettled(promises).then(results => {
        // Filter out only the fulfilled promises and extract their values
        return results
            .filter(result => result.status === 'fulfilled')
            .map(result => result.value).sort((a, b) => a.responseTime - b.responseTime).forEach((user,index) => {
                //users.sort((a, b) => a.reactionTime - b.reactionTime);


                // Loop through the top 10 users or available users
                // const topUsers = users.slice(0, 10);
                // topUsers.forEach((user, index) => {
                    // Create a new row
                    console.log("\tUSER: ",user,"PLACE: ",index);
                    const newRow = leaderboardBody.insertRow();

                    // Insert cells for place, userID, and reaction time
                    const cellPlace = newRow.insertCell(0);
                    const cellUserID = newRow.insertCell(1);
                    const cellReactionTime = newRow.insertCell(2);

                    // Set the text content for each cell
                    cellPlace.textContent = index + 1; // Place
                    cellUserID.textContent = user.username; // UserID
                    cellReactionTime.textContent = user.responseTime; // Reaction Time
                //});


            });
    });
  }

  function getObjectFromS3(bucket, key) {
    const url = `/s3/get-object/bucket/${bucket}/key/${encodeURIComponent(key)}`;
    
    return fetch(url)
        .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
        })
        .then(data => {
        console.log('Data received:', data);
        // Handle the received data
        return data;  // Return the data from this promise
        })
        .catch(error => {
        console.error('Error fetching object:', error);
        // Handle the error
        throw error; // Re-throw the error for the caller to handle
    });
  }


  async function fetchS3ObjectList() {

    let users = [];

    try {
        const response = await fetch('/s3/list-objects');

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const responseData = await response.json();
        console.log('Successfully got objects from S3 buckets: ', responseData);
        for (elem in responseData.data) {
            if (isDirectory(responseData.data[elem].Key)) {
                let directory =  getDirectory(responseData.data[elem].Key);
                if (directory == 'leaderboard') {
                    try {
                        // Clear previous messages and data

                        const bucketName = 'cheesebucketlehighu'; // Replace with your actual bucket name
                        const objectKey = responseData.data[elem].Key;     // Replace with your actual JSON object key

                        users.push(getObjectFromS3(bucketName, objectKey));
                    } catch (error) {
                        console.error('Error fetching JSON object:', error);
                        message.textContent = `Error fetching JSON object: ${error.message}`;
                    }
                }
                
            }
        }
        console.log("USERS.length ",users.length)
        accessPromiseResults(users);
    } catch (error) {
        console.error('Error fetching S3 object list:', error);
    }
  }


 

  // Call function to initialize camera stream

  // Function to begin webgazer
  async function beginWebgazer() {

    await initializeCameraStream();
    console.log("Beginning webgazer with... ")
    console.log(cameraStream)
    webgazer.setGazeListener(function(data, elapsedTime) {
        if (data == null) {
            //console.log("No data to print :(");
            return;
        }
        var xprediction = data.x; // these x coordinates are relative to the viewport
        var yprediction = data.y; // these y coordinates are relative to the viewport
        //console.log("x: " + xprediction + ", y: " + yprediction);
        gazeData.push([xprediction,yprediction]);
    }).begin(onFail,cameraStream);

  }

  var timeline = []; // this array stores the events we want to run in the experiment
  
  var trial_ind = 1; // trial indexing variable starts at 1 for convenience

  var block_ind = 0; // block indexing variables: block 0 is considered to be the practice block

  var focus = 'focus'; // tracks if the current tab/window is the active tab/window, initially the current tab should be focused
  var fullscr_ON = 'no'; // tracks fullscreen activity, initially not activated
  var redirect_timeout = 1500; // set this so that data is saved before redirect!

  // is the experiment running from a server or not? (this determines if data is saved on server or offline)
  if (document.location.host) { // returns your host or null
    online = true;
  } else {
    online = false;
  };

  // detect visitor variables with the bowser js library (/js/bowser.js)

  jsPsych.data.addProperties({ // add these variables to all rows of the datafile

    browser_name: bowser.name, browser_version: bowser.version,

    os_name: bowser.osname, os_version: bowser.osversion,

    tablet: String(bowser.tablet), mobile: String(bowser.mobile),
 // convert explicitly to string so that "undefined" (no response) does not lead to empty cells in the datafile
    screen_resolution: screen.width + ' x ' + screen.height,

    window_resolution: window.innerWidth + ' x ' + window.innerHeight, // this will be updated throughout the experiment

  });
  // define the images to be loaded, the actual preloading occurs in the jsPsych.init function at the bottom

  var pre_load_stimuli = [fix_stim, go_stim1, go_stim2, stop_stim1, stop_stim2];

  /* #########################################################################

  Create the design based on the input from 'experiment_variables.js'

  ######################################################################### */

  // Since we have two stimuli, the number of trials of the basic design = 2 * nstim

  // This design will later be repeated a few times for each block

  // (number of repetitions is also defined in 'experiment_variables.js')

  var ngostop = 1/nprop      // covert proportion to trial numbers. E.g. 1/5 = 1 stop signal and 4 go

  var ntrials = ngostop * 2  // total number of trials in basic design (2 two choice stimuli x ngostop)

  var signalArray = Array(ngostop-1).fill('go'); // no-signal trials

  signalArray[ngostop-1] = ('stop'); // stop-signal trials

  // create factorial design from choices(2) and signal(nstim)

  var factors = {

    stim: [choice_stim1, choice_stim2],

    signal: signalArray,

  };

  var design = jsPsych.randomization.factorial(factors, 1);

  // modify the design to make it compatible with the custom stop signal plugin

  //  - set a first/second stimulus property.

  //    on no-signal trials, only one image will be used (i.e. the go image/stimulus)

  //    on stop-signal trials, two images will be used (i.e. the go and stop images/stimuli)

  //  - set a data property with additional attributes for identifying the type of trial

  for (var i = 0; i < design.length; i++) {

      design[i].data = {}

      if ((design[i].stim == choice_stim1) && (design[i].signal == 'go')) {

        design[i].fixation = fix_stim;
        design[i].first_stimulus = go_stim1;

        design[i].second_stimulus = go_stim1;

        design[i].data.stim = choice_stim1;

        design[i].data.correct_response = '0';

        design[i].data.signal = "no";

      } else if ((design[i].stim == choice_stim2) && (design[i].signal == 'go')) {

        design[i].fixation = fix_stim;
        design[i].first_stimulus = go_stim2;

        design[i].second_stimulus = go_stim2;

        design[i].data.stim = choice_stim2;

        design[i].data.correct_response = '1';

        design[i].data.signal = "no";

      } else if ((design[i].stim == choice_stim1) && (design[i].signal == 'stop')) {

        design[i].fixation = fix_stim;
        design[i].first_stimulus = go_stim1;

        design[i].second_stimulus = stop_stim1;

        design[i].data.stim = choice_stim1;

        design[i].data.correct_response = "null";

        design[i].data.signal = "yes";

      } else if ((design[i].stim == choice_stim2) && (design[i].signal == 'stop')) {

        design[i].fixation = fix_stim;
        design[i].first_stimulus = go_stim2;

        design[i].second_stimulus = stop_stim2;

        design[i].data.stim = choice_stim2;

        design[i].data.correct_response = "null";

        design[i].data.signal = "yes";

      }

      delete design[i].signal; delete design[i].stim;

  };



  //console.log(design); // uncomment to print the design in the browser's console



  /* #########################################################################

  Define the individual events/trials that make up the experiment

  ######################################################################### */



  // welcome message trial. Also: end the experiment if browser is not Chrome or Firefox

  var welcome = {

    type: "instructions",

    pages: welcome_message,

    show_clickable_nav: true,

    allow_backward: false,
    button_label_next: label_next_button,

    on_start: function(trial) { 

      if (bowser.name == 'Firefox' || bowser.name == 'Chrome'){

        trial.pages = welcome_message;

      } else {

        trial.pages = not_supported_message;

        setTimeout(function(){location.href="html/not_supported.html"}, 2000);
      }

    },

    

  };
  // these events turn fullscreen mode on in the beginning and off at the end, if enabled (see experiment_variables.js)

  var fullscr = {

    type: 'fullscreen',

    fullscreen_mode: true,

    message: full_screen_message,
    button_label: label_next_button,
  };

  var fullscr_off = {

    type: 'fullscreen',

    fullscreen_mode: false,

    button_label: label_next_button,
  };



  // informed consent trial. The informed_consent_text variable comes from /configuration/text_variables.js

  var consent = {

    type: "instructions",

    pages: [informed_consent_text],

    show_clickable_nav: true,

    button_label_next: label_consent_button,

    allow_backward: false
  };



  // if enabled below, get participant's id from participant and add it to the datafile.

  // the prompt is declared in the configuration/text_variables.js file

  var participant_id = {

    type: 'survey-text',

    questions: [{

      prompt: subjID_instructions,

      required: true

    }, ],

    button_label: label_next_button,
    on_finish: function(data) {

      var responses = JSON.parse(data.responses);

      var code = responses.Q0;

      jsPsych.data.addProperties({

        participantID: code

      });

    }

  };



  // get participant's age and add it to the datafile

  // the prompt is declared in the configuration/text_variables.js file

  var age = {

    type: 'survey-text',

    questions: [{

      prompt: age_instructions,

      required: true

    }, ],

    button_label: label_next_button,
    on_finish: function(data) {

      var responses = JSON.parse(data.responses);

      var code = responses.Q0;

      jsPsych.data.addProperties({

        age: code

      });

    }

  };

  var username = {

  type: 'survey-text',

  questions: [{

    prompt: username_instructions,

    required: true

  }, ],

  button_label: label_next_button,
  on_finish: function(data) {

    var responses = JSON.parse(data.responses);

    var code = responses.Q0;

    jsPsych.data.addProperties({

      username: code

    });

  }

  };




  // get participant's gender and add it to the datafile

  // the prompt and options are declared in the configuration/text_variables.js file

  var gender = {

    type: 'survey-multi-choice',

    questions: [{

      prompt: gender_instructions,

      options: gender_options,

      required: true

    }, ],

    button_label: label_next_button,
    on_finish: function(data) {

      var responses = JSON.parse(data.responses);

      var code = responses.Q0;

      jsPsych.data.addProperties({

        gender: code

      });

    }

  };



// };

  // var webcam_permission = {

  //   type: "custom-realeyes-plugin",

  //   stimulus: 'Please enable facial expression recognition',
  //   choices: ['Init SDK','Start','Stop']

  // };



  // instruction trial

  // the instructions are declared in the configuration/text_variables.js file

  var instructions = {

    type: "instructions",

    pages: [page1, page2],

    show_clickable_nav: true
,
    button_label_previous: label_previous_button,
    button_label_next: label_next_button,
  };



  // start of each block

  // the start message is declared in the configuration/text_variables.js file

  var block_start = {

    type: 'html-button-response',

    stimulus: text_at_start_block,
    choices: ['Proceed'],


  };

  var start_webgazer= {

    type: 'html-button-response',

    stimulus: 'Press the button to begin eyetrackings',
    choices: ['Start Eyetracking'],

    on_finish: function(trial) { 
      
      beginWebgazer();

    }

  };

  // get ready for beginning of block

  // the get ready message is declared in the configuration/text_variables.js file

  var block_get_ready = {

    type: 'html-keyboard-response',

    stimulus: get_ready_message,

    choices: jsPsych.NO_KEYS,

    trial_duration: 2000,

  };


  // blank inter-trial interval
  var blank_ITI = {

    type: 'jspsych-detect-held-down-keys',
 // this enables the detection of held down keys
    stimulus: "",
 // blank
    trial_duration: ITI/2,

    response_ends_trial: false,

  };
// now put the trial in a node that loops (if response is registered)
  var held_down_node = {
      timeline: [blank_ITI],
      loop_function: function(data){
          if(data.values()[0].key_press != null){
              return true; // keep looping when a response is registered
          } else {
              return false; // break out of loop when no response is registered
          }
      }
  };


  // the main stimulus

  // use custom-stop-signal-plugin.js to show three consecutive stimuli within one trial
  // (fixation -> first stimulus -> second stimulus, with variable inter-stimuli-intervals)

  var stimulus = {

    type: 'custom-stop-signal-plugin',

    fixation: jsPsych.timelineVariable('fixation'),
    fixation_duration: FIX,
    stimulus1: jsPsych.timelineVariable('first_stimulus'),

    stimulus2: jsPsych.timelineVariable('second_stimulus'),

    trial_duration: MAXRT, // this is the max duration of the actual stimulus (excluding fixation time)
    // inter stimulus interval between first and second stimulus = stop signal delay (SSD)
    ISI: function() {
      var duration = SSD;

      return duration

    },
    response_ends_trial: true,

    choices: ['Left','Right'],

    data: jsPsych.timelineVariable('data'),

    // was the response correct? adapt SSD accordingly

    on_finish: function(data) {

      // check if the response was correct
      data.response = data.button_press; // keys are stored in keycodes not in character, so convert for convenience
      data.response = String(data.response)
      console.log('data.response: ' + data.response)
      data.correct = data.response == data.correct_response;

      // if no response was made, the reaction time should not be -250 but null
      if (data.rt == -250) {
        data.rt = null
      };
      // on go trials, reaction times on the fixation (below zero) are always wrong
      if (data.signal == 'no' && data.rt < 0){
        data.correct = false;
      };
      // set and adapt stop signal delay (SSD)
      data.SSD = SSD;

      data.trial_i = trial_ind;

      data.block_i = block_ind;

      trial_ind = trial_ind + 1;

      if (data.signal == 'yes') {

        if (data.correct) {

          SSD = SSD + SSDstep;

          if (SSD >= MAXRT) {

            SSD = MAXRT - SSDstep

          };

        } else {

          SSD = SSD - SSDstep;

          if (SSD <= SSDstep) {

            SSD = SSDstep

          };

        }

      }

    }

  };



  // trial-by-trial feedback

  // messages are defined in the configuration/text_variables.js file

  var trial_feedback = {

    type: 'html-keyboard-response',

    choices: jsPsych.NO_KEYS,

    trial_duration: iFBT,

    stimulus: function() {

      var last_trial_data = jsPsych.data.get().last(1).values()[0];

      if (last_trial_data['signal'] === 'no') {
 // go trials
        if (last_trial_data['correct']) {

          return correct_msg

        } else {

          if (last_trial_data['response'] === "undefined") {
 // no response previous trial
            return too_slow_msg
          } else {

            if (last_trial_data['rt'] >= 0) {
              return incorrect_msg
            } else {
              return too_fast_msg
            }
          }

        }

      } else {
 // stop trials
        if (last_trial_data['correct']) {

          return correct_stop_msg

        } else {

          if (last_trial_data['rt'] >= 0) {
            return incorrect_stop_msg
          } else {
            return too_fast_msg
          }
        }

      }

    }

  };



  // at the end of the block, give feedback on performance

  var block_feedback = {

    type: 'html-button-response',

    trial_duration: bFBT,

    choices: function() {

      if (block_ind == NexpBL){

        return ['Proceed']

      } else {

        return ['Skip'] // 'p' can be used to skip the feedback, useful for debugging

      }

    },

    stimulus: function() {

      // calculate performance measures

      var ns_trials = jsPsych.data.get().filter({

        trial_type: 'custom-stop-signal-plugin',

        block_i: block_ind,

        signal: 'no'

      });

      var avg_nsRT = Math.round(ns_trials.select('rt').subset(function(x){ return x > 0; }).mean());

      var prop_ns_Correct = Math.round(ns_trials.filter({

        correct: true

      }).count() / ns_trials.count() * 1000) / 1000; // unhandy multiplying and dividing by 1000 necessary to round to two decimals

      var prop_ns_Missed = Math.round(ns_trials.filter({

        key_press: null

      }).count() / ns_trials.count() * 1000) / 1000;

      var prop_ns_Incorrect = Math.round((1 - (prop_ns_Correct + prop_ns_Missed)) * 1000) / 1000;

      var ss_trials = jsPsych.data.get().filter({

        trial_type: 'custom-stop-signal-plugin',

        block_i: block_ind,

        signal: 'yes'

      });

      var prop_ss_Correct = Math.round(ss_trials.filter({

        correct: true

      }).count() / ss_trials.count() * 1000) / 1000;

      // in the last block, we should not say that there will be a next block

      if (block_ind == NexpBL) {

        var next_block_text = final_block_msg

      } else { // make a countdown timer

        var count=(bFBT/1000);

        var counter;

        clearInterval(counter);

        counter=setInterval(timer, 1000); //1000 will run it every 1 second

        function timer(){

          count=count-1;

          if (count <= 0){

              clearInterval(counter);

          }

          let timer = document.getElementById("timer")
          if (timer) {
            timer.innerHTML = count;
          }
          
        }

        var next_block_text = next_block_msg // insert countdown timer

      }

      // the final text to present. Can also show correct and incorrect proportions if requested.

      return [

        no_signal_header +

        sprintf(avg_rt_msg,avg_nsRT) +
        sprintf(prop_miss_msg,prop_ns_Missed) +
        stop_signal_header +
        sprintf(prop_corr_msg,prop_ss_Correct) +
        next_block_text

      ]

    },

    on_finish: function() {

      trial_ind = 1; // reset trial counter

      block_ind = block_ind + 1; // next block

    }

  };


  var evaluate_end_if_practice = {
    type: 'call-function',
    func: function() {
      if (block_ind == 0) { // this limits the amount of trials in the practice block
        if (trial_ind > NdesignReps_practice * ntrials) {
          jsPsych.endCurrentTimeline();
        }
      }
    }
  };


  // end trial and save the data

  var goodbye = {

    type: "custom-goodbye-plugin",

    stimulus: end_message,

    choices:['Done'],

    on_start: function(data) {

      //mediaRecorder.stop()

      // for (let i = 0; i < 20; i++) {
      //   jsPsych.data.write({
      //     participantID: `P${Math.floor(Math.random() * 9000) + 1000}`,           // Simulated participant ID
      //     age: Math.floor(Math.random() * (70 - 18 + 1)) + 18, // Random age between 18 and 70
      //     gender: ['male', 'female', 'non-binary'][Math.floor(Math.random() * 3)], // Random gender
      //     block_i: Math.floor(Math.random() * 5) + 1,  // Random block index between 1 and 5
      //     trial_i: Math.floor(Math.random() * 50) + 1, // Random trial index between 1 and 50
      //     stim: `stimulus_${Math.floor(Math.random() * 10) + 1}`, // Random stimulus label
      //     signal: Math.random() < 0.5 ? 'go' : 'stop', // Random signal (either 'go' or 'stop')
      //     SSD: Math.floor(Math.random() * 500) + 200,  // Random Stop Signal Delay between 200 and 700 ms
      //     response: Math.random() < 0.5 ? 'left' : 'right', // Random response ('left' or 'right')
      //     rt: Math.floor(Math.random() * 1500) + 200,  // Random reaction time between 200 and 1700 ms
      //     correct: Math.random() < 0.8,                // 80% chance of being correct
      //     focus: Math.random() < 0.9,                  // 90% chance of being focused
      //     Fullscreen: Math.random() < 0.8,             // 80% chance of being in fullscreen
      //     time_elapsed: Math.floor(Math.random() * 600000), // Random time elapsed in milliseconds (up to 10 minutes)
      //     browser_name: ['Chrome', 'Firefox', 'Safari', 'Edge'][Math.floor(Math.random() * 4)], // Random browser
      //     browser_version: `${Math.floor(Math.random() * 80) + 20}.0`, // Random browser version between 20 and 100
      //     os_name: ['Windows', 'macOS', 'Linux', 'Android', 'iOS'][Math.floor(Math.random() * 5)], // Random OS
      //     os_version: `${Math.floor(Math.random() * 15) + 1}.0`, // Random OS version between 1 and 15
      //     tablet: Math.random() < 0.1,                 // 10% chance of being on a tablet
      //     mobile: Math.random() < 0.3,                 // 30% chance of being on a mobile device
      //     screen_resolution: `${Math.floor(Math.random() * 400) + 800}x${Math.floor(Math.random() * 400) + 600}`, // Random screen resolution
      //     window_resolution: `${Math.floor(Math.random() * 400) + 800}x${Math.floor(Math.random() * 400) + 600}`, // Random window resolution
      //     positive_emotion_score: Math.floor(Math.random() * 101), // Random positive emotion score between 0 and 100
      //     negative_emotion_score: Math.floor(Math.random() * 101), // Random negative emotion score between 0 and 100
      //     attention_score: Math.floor(Math.random() * 101),        // Random attention score between 0 and 100
      //     timestamp: new Date().toISOString(),                      // Current timestamp in ISO format
      //     trial_type: 'custom-stop-signal-plugin'                       // Custom trial type
      //   });
      // }

      console.log(jsPsych.data.get().values());

      var subjID = jsPsych.data.get().last(1).values()[0]['participantID'];
      var username = jsPsych.data.get().last(1).values()[0]['username'];
      var full_data = jsPsych.data.get();
      var ignore_columns = ['raw_rt','trial_type','first_stimulus','second_stimulus','onset_of_first_stimulus',
        'onset_of_second_stimulus','key_press','correct_response','trial_index','internal_node_id'];
      //var rows = {trial_type: 'custom-stop-signal-plugin'}; // we are only interested in our main stimulus, not fixation, feedback etc.
      var rows = {trial_type: 'custom-stop-signal-plugin'}; // we are only interested in our main stimulus, not fixation, feedback etc.

      var selected_data = jsPsych.data.get().filter(rows).ignore(ignore_columns);
      // the next piece of codes orders the columns of the data file
      var d = selected_data.values() // get the data values

      console.log(selected_data.csv());

      uploadData( subjID ,selected_data.csv());

      // make an array that specifies the order of the object properties

      

      // var arr = ['participantID','age','gender','block_i','trial_i','stim','signal','SSD','response','rt','correct','focus','Fullscreen',
      // 'time_elapsed','browser_name','browser_version','os_name','os_version','tablet','mobile','screen_resolution','window_resolution','positive_emotion_score','negative_emotion_score','attention_score','timestamp'];

      // var eye_tracking_data_arr = ['participant_id','x','y'];

      // new_arr = [] // we will fill this array with the ordered data
      // function myFunction(item) { // this is function is called in the arr.forEach call below
      //   new_obj[item] = obj[item]
      //   return new_obj
      // }
      // // do it for the whole data array
      // for (i = 0; i < d.length; i++) {
      //   obj = d[i]; // get one row of data
      //   new_obj = {};
      //   arr.forEach(myFunction) // for each element in the array run my function
      //   selected_data.values()[i] = new_obj; // insert the ordered values back in the jsPsych.data object
      // }
      // if (!online) {
      //   selected_data.localSave('csv', 'SST_data_' + subjID + '.csv');

      //   // Convert data to CSV format
      //   const csvHeader = 'x,y\n';
      //   const csvRows = gazeData.map(row => `${Math.round(row[0])},${Math.round(row[1])}`).join('\n');
      //   const csvContent = csvHeader + csvRows;

      //   // Create a Blob with the CSV data
      //   const blob = new Blob([csvContent], { type: 'text/csv' });
        
      //   // Create a link element to trigger the download
      //   const link = document.createElement('a');
      //   link.href = URL.createObjectURL(blob);
      //   link.download = 'eye_tracking_data_' + subjID + '_.csv';
        
      //   // Append the link to the body and trigger the click event
      //   document.body.appendChild(link);
      //   link.click();
        
      //   // Clean up and remove the link element
      //   document.body.removeChild(link);
      // } else {

      //   data_row = 'x,y';
      //   appendData('eye_tracking_data_' + subjID + '_.csv',data_row)

      //   for (let i = 0; i < gazeData.length; i ++) {
      //     new_data_row = `${gazeData[i][0]}, ${gazeData[i][1]}`
      //     appendData('eye_tracking_data_' + subjID + '_.csv',new_data_row)
      //   }
      // }

      const all_trials = jsPsych.data.get().filter({trial_type: 'custom-stop-signal-plugin'});

      // handleStop()

      uploadToLeaderboard(username,subjID, Math.round(all_trials.select('rt').subset(function(x){ return x > 0; }).mean()))
      .then(() => {
        fetchS3ObjectList();
      });
      }

  };



  /* #########################################################################

  combine trials in procedures (create nested timeline)

  ######################################################################### */



  // only ask for participant id if 'id' = 'particpant' (experiment_variables.js)

  // if 'id' = 'url', get it from url; otherwise, generate random value

  // only go into fullscreen mode if 'fullscreen' is true

  if (id == "participant"){

    if (fullscreen){

      var start_timeline = [//debug,
      welcome,
      //webcam_permission
      , consent, participant_id, gender, fullscr, instructions]

    } else {

      var start_timeline = [//debug,
      welcome,
      //webcam_permission
      , consent, participant_id, gender, instructions]

    }

  } else {

      if (id == "url"){

        var urlvar = jsPsych.data.urlVariables();

        var code = urlvar.subject; jsPsych.data.addProperties({participantID: code});

      } else {

        var code = jsPsych.randomization.randomID(); jsPsych.data.addProperties({participantID: code});

      }

      if (fullscreen) {

        var start_timeline = [//debug,
        welcome,
        //webcam_permission,
         consent,username, gender, fullscr, instructions]

      } else {

        var start_timeline = [//debug,
        welcome,
        //webcam_permission, 
        consent,username, gender, instructions]

      }

  }



  // start the experiment with the previously defined start_timeline trials

  var start_procedure = {

    timeline: start_timeline,

  };



  // put trial_feedback in its own timeline to make it conditional (only to be shown during the practice block)

  var feedback_node = {

    timeline: [trial_feedback],

    conditional_function: function() {

      var last_trial_data = jsPsych.data.get().last(1).values()[0];
      var current_block = block_ind;

      if (current_block == 0) {
 // this was previously set to provide feedback only on incorrect trials by adding: && last_trial_data['correct']==false
        return true;

      } else {

        return false;

      }

    }

  };



  // timeline_variables determine the stimuli in the 'stimulus' trial

  var trial_procedure = {

    timeline: [blank_ITI, held_down_node, stimulus, feedback_node, evaluate_end_if_practice],

    timeline_variables: design,

    randomize_order: true,

    repetitions: NdesignReps_exp,

  };



  // again: combine the following screen in one timeline, which constitues of the procedure of one block

  var block_procedure = {

    timeline: [block_start, block_get_ready, trial_procedure, block_feedback],

    randomize_order: false,

    repetitions: NexpBL+1, // add one because the first block is the practice block

  };



  // end of the experiment

  if (fullscreen){

    end_timeline = [fullscr_off, goodbye]

  } else {

    end_timeline = [goodbye]

  }



  var end_procedure = {

    timeline: end_timeline, // here, you could add questionnaire trials etc...

  };



  // finally, push all the procedures to the overall timeline


    var pavlovia_init = {
      type: "pavlovia",
      command: "init"
  };

  var pavlovia_finish = {
    type: "pavlovia",
    command: "finish"
  };



  timeline.push(
    //pavlovia_init,
  start_procedure,
  start_webgazer,
   block_procedure, end_procedure
  //,pavlovia_finish
  )




  /* #########################################################################

  the functions that save the data and initiates the experiment

  ######################################################################### */



  // function that appends data to an existing file (or creates the file if it does not exist)

  function appendData(filename, filedata) {

    // $.ajax({ // make sure jquery-1.7.1.min.js is loaded in the html header for this to work

    //   type: 'post',

    //   cache: false,

    //   url: 'php/save_data_append.php', // IMPORTANT: change the php script to link to the directory of your server where you want to store the data!

    //   data: {

    //     filename: filename,
 
    //     filedata: filedata

    //   },

    // });

  };



  // run the experiment!

  jsPsych.init({

    timeline: timeline,
    //[goodbye],

    preload_images: pre_load_stimuli,

    on_data_update: function(data) { // each time the data is updated:

      // write the current window resolution to the data

      data.window_resolution =  window.innerWidth + ' x ' + window.innerHeight;

      // is the experiment window the active window? (focus = yes, blur = no)

      data.focus = focus; data.Fullscreen = fullscr_ON;

      // append a subset of the data each time a go or stop stimulus is shown (the custom-stop-signal-plugin)

      id_index = 2;
      // point in experiment when particpant id is manually entered. see 'start_timeline'
      if (online) {

        var subjID = jsPsych.data.get().last(1).values()[0]['participantID'];

        if (data.trial_index == id_index){ // write header

          data_row = "participantID,age,gender,block_i,trial_i,stim,signal,SSD,response,rt,correct," +
                        "focus,Fullscreen,time_elapsed,browser_name,browser_version,os_name,os_version," +
                        "tablet,mobile,screen_resolution,window_resolution,positive_emotion_score,negative_emotion_score,attention_score,timestamp\n"
          appendData('SST_data_'+ subjID +'.csv',data_row)

        } else if (data.trial_type == 'custom-stop-signal-plugin'){ // append data each stimulus

          data_row = data.participantID + ',' + data.age + ',' + data.gender + ',' + data.block_i + ',' + data.trial_i + ',' +
                        data.stim + ',' + data.signal + ',' + data.SSD + ',' + data.response + ',' + data.rt + ',' + data.correct + ',' +
                        data.focus + ',' + data.Fullscreen + ',' + data.time_elapsed + ',' + data.browser_name + ',' +
                        data.browser_version + ',' + data.os_name + ',' + data.os_version + ',' + data.tablet + ',' + data.mobile + ',' +
                        data.screen_resolution + ',' + data.window_resolution + ',' + data.positive_emotion_score + ',' + data.negative_emotion_score + ',' + data.attention_score + ',' + data.timestamp + '\n'
          appendData('SST_data_'+ subjID +'.csv',data_row)

        }

      }

    },

    on_interaction_data_update: function(data) { //interaction data logs if participants leaves the browser window or exits full screen mode

      interaction = data.event;

      if (interaction.includes("fullscreen")){
 // some unhandy coding to circumvent a bug in jspsych that logs fullscreenexit when actually entering
        if (fullscr_ON == 'no') {fullscr_ON = 'yes'; return fullscr_ON}

        else if (fullscr_ON == 'yes') {fullscr_ON = 'no'; return fullscr_ON}

      }  else if (interaction == 'blur' || interaction == 'focus'){

        focus = interaction;

        return focus;

      }

    },

    exclusions: { // browser window needs to have these dimensions, if not, participants get the chance to maximize their window, if they don't support this resolution when maximized they can't particiate.

      min_width: minWidth,

      min_height: minHeight

    },

    on_finish: function() {

      if (redirect_onCompletion){

        setTimeout("location.href = '" + redirect_link + "';",redirect_timeout); // redirect to another URL with a certain delay, only when redirect_onCompletion is set to 'true'

      }

    },

  })

</script>



</html>

